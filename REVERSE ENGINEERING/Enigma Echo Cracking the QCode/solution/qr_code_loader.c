/*
Description of the Program:

This C program is designed to operate on the Windows platform, utilizing various Windows-specific libraries and APIs for file handling, 
encryption/decryption. 
The primary purpose of the program is to perform decryption of a file using the RC4 algorithm, provided the correct key is supplied.
The program includes validation checks for the encryption key and the file format, specifically targeting PNG files with a particular header.

Overview of Each Function:

1. DisplayError(LPTSTR lpszFunction):
   - Purpose: To display detailed error messages corresponding to the last error code generated by a system call.
   - Parameters: The name of the function where the error occurred.
   - Returns: Nothing.

2. getFileSize(LPCWSTR filepath):
   - Purpose: To determine the size of a file.
   - Parameters: File path of the target file.
   - Returns: The size of the file as a LARGE_INTEGER.

3. ReadFileContent(_TCHAR* filepath, int64_t fileSize):
   - Purpose: To read the content of a file into memory.
   - Parameters: Path of the file and its size.
   - Returns: A pointer to the buffer containing the file's content.

4. RC4_decryption_systemfunction032(LPVOID buffer, TCHAR* encryption_key, int64_t fileSize):
   - Purpose: To decrypt data using the RC4 algorithm by calling the 'SystemFunction032' from advapi32.dll.
   - Parameters: Buffer containing data to decrypt, encryption key, and size of the data.
   - Returns: TRUE if decryption is successful, FALSE otherwise.

5. WriteFileContent(LPVOID buffer, SIZE_T bufferSize, TCHAR* outputpath):
   - Purpose: To write data to a file.
   - Parameters: Buffer containing data, size of the data, and output file path.
   - Returns: TRUE if writing is successful, FALSE otherwise.

6. XOR(const char* data, SIZE_T data_len, char* result):
   - Purpose: To perform XOR operation on data.
   - Parameters: Input data, length of data, and buffer to store the result.
   - Returns: Nothing.

7. validate_key(LPWSTR user_key):
   - Purpose: To validate the encryption key provided by the user.
   - Parameters: User-provided encryption key.
   - Returns: TRUE if the key is valid, FALSE otherwise.

8. ShowHelp():
   - Purpose: To display help information about how to use the program.
   - Parameters: None.
   - Returns: Nothing.

9. print_currentdir_path():
   - Purpose: To print the current directory path.
   - Parameters: None.
   - Returns: Nothing.

10. validatePNGFile(LPWSTR encrypted_file_path):
    - Purpose: To validate whether the provided AES encrypted file is a right PNG file based on its heade or not. 
    - Parameters: Path to the encrypted file.
    - Returns: TRUE if the file is a valid PNG file, FALSE otherwise.

11. _tmain(int argc, TCHAR* argv[]):
    - Purpose: The main entry point for the program. It parses command line arguments and orchestrates the file decryption process.
    - Parameters: Number of command line arguments and the argument vector.
    - Returns: An integer status code.

Each function is designed with specific roles in the decryption process, ensuring the program executes efficiently and handles errors effectively.
*/


#include <Windows.h>
#include <stdio.h>
#include <tchar.h>
#include <stdint.h>
#include <strsafe.h>
#include <ntstatus.h>
#include <sal.h>
#include <string.h>
#include <xmmintrin.h>

#pragma comment(lib, "advapi32.lib")


// Encrypt0r_K3yMast3r! XORed with key 0x3d
char xor_buffer[] = {0x78,0x53,0x5e,0x4f,0x44,0x4d,0x49,0x0d,0x4f,0x62,0x76,0x0e,0x44,0x70,0x5c,0x4e,0x49,0x0e,0x4f,0x1c};

// AES encrypted File: 2C3D4E5F.DAT --> header : 96 10 3C B1 57 B2 C0 22 F0 2A 5E E6 44 53 59 3B XORed with 0x3d
char xor_png_header[] = { 0xab,0x2d,0x01,0x8c,0x6a,0x8f,0xfd,0x1f,0xcd,0x17,0x63,0xdb,0x79,0x6e,0x64,0x06 };


/*
struct ustring:
    - Description: Represents a string data structure used for handling strings in certain Windows API calls. It is typically used in scenarios where strings are manipulated at a lower level, especially in cryptographic operations.
    - Fields:
        - DWORD Lenght: The current length of the string.
        - DWORD MaximumLength: The maximum length that the string can accommodate. This is important for buffer allocation and security.
        - PUCHAR Buffer: A pointer to an unsigned char type, representing the buffer that holds the string data.

_SystemFuntion033 and _SystemFuntion032:
    - Description: These are typedefs for function pointers to Windows API functions, specifically used for cryptographic operations. The exact functions they point to are not part of the standard public Windows API but are often used for lower-level system and security tasks. They appear to be related to encryption or decryption routines.
    - Parameters:
        - ustring* memoryRegion: A pointer to a 'ustring' structure that likely contains data to be encrypted or decrypted.
        - ustring* keyPointer: A pointer to a 'ustring' structure that likely contains the cryptographic key or related information.
    - Return Type: NTSTATUS, which is a typical return type for Windows system calls, indicating the success or failure of the operation. 'NTSTATUS' values are used to report various system and operation statuses, both success and error cases.
*/

struct ustring
{
    DWORD Lenght;
    DWORD MaximumLength;
    PUCHAR Buffer;
};
typedef NTSTATUS(WINAPI* _SystemFuntion033)(struct ustring* memoryRegion, struct ustring* keyPointer);
typedef NTSTATUS(WINAPI* _SystemFuntion032)(struct ustring* memoryRegion, struct ustring* keyPointer);


void DisplayError(LPTSTR lpszFunction)
// Routine Description:
// Retrieve and output the system error message for the last-error code
{
    LPVOID lpMsgBuf;
    LPVOID lpDisplayBuf;
    DWORD dw = GetLastError();

    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        dw,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        (LPTSTR)&lpMsgBuf,
        0,
        NULL);

    lpDisplayBuf =
        (LPVOID)LocalAlloc(LMEM_ZEROINIT,
            (lstrlen((LPCTSTR)lpMsgBuf) + lstrlen((LPCTSTR)lpszFunction) + 40) // account for format string
            * sizeof(TCHAR));

    if (FAILED(StringCchPrintf((LPTSTR)lpDisplayBuf,
        LocalSize(lpDisplayBuf) / sizeof(TCHAR),
        TEXT("%s failed with error code %d as follows:\n%s"),
        lpszFunction,
        dw,
        lpMsgBuf)))
    {
        printf("FATAL ERROR: Unable to output error code.\n");
    }

    _tprintf(TEXT("ERROR: %s\n"), (LPCTSTR)lpDisplayBuf);

    LocalFree(lpMsgBuf);
    LocalFree(lpDisplayBuf);
}

/*
Function: LARGE_INTEGER getFileSize(LPCWSTR filepath)

- Description: This function retrieves the size of a file specified by the given file path. It is designed to work on Windows platforms and uses the Win32 API for file operations. The function is robust in that it handles errors gracefully, returning an indicative value if the file cannot be opened or if its size cannot be determined.

- Parameters:
  - LPCWSTR filepath: A pointer to a wide character string that represents the path to the file whose size is to be determined. The 'LPCWSTR' type ensures compatibility with Unicode file paths.

- Returns:
  - LARGE_INTEGER: This return type is a 64-bit integer (part of the Win32 API) that can represent very large file sizes. It is necessary because files in modern systems can be larger than what a standard 32-bit integer can represent.

- Functionality:
  1. The function initializes a LARGE_INTEGER variable named 'fileSize' with an error value (-1). This error value is used to indicate failure if the file cannot be opened or its size cannot be determined.
  2. It attempts to open the specified file for reading using 'CreateFileW', a Windows API function that supports Unicode file paths.
  3. If the file is successfully opened, the function then calls 'GetFileSizeEx' to obtain the size of the file. 'GetFileSizeEx' is a more modern and reliable alternative to the older 'GetFileSize' function.
  4. If the file cannot be opened, or if its size cannot be determined, the function prints an error message and returns the initial error value.
  5. Upon successful determination of the file size, the function closes the file handle and returns the size.
*/

LARGE_INTEGER  getFileSize(LPCWSTR filepath)
{
    LARGE_INTEGER fileSize;
    fileSize.QuadPart = -1;  // Initialize with an error value
    HANDLE hFile = CreateFileW(
        filepath,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
    );

    if (hFile == INVALID_HANDLE_VALUE) {
        wprintf(L"[!] Error: Unable to open the file.\n");
        return fileSize;
    }

    if (!GetFileSizeEx(hFile, &fileSize)) {
        wprintf(L"[!] Error: Unable to get the file size.\n");
        CloseHandle(hFile);
        return fileSize;
    }
    CloseHandle(hFile);
    return fileSize;

}

LPVOID ReadFileContent(_TCHAR* filepath, int64_t fileSize)
{
   
    HANDLE hFile;
    hFile = CreateFile(
        filepath,              // name of the file
        GENERIC_READ,          // open file for reading
        FILE_SHARE_READ,       // share for reading
        NULL,                  // default security
        OPEN_EXISTING,         // existing file only
        FILE_ATTRIBUTE_NORMAL, // normal file
        NULL                   // no attr. template
    );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DisplayError(TEXT("CreateFile"));
    }
    HANDLE hMyheap;
    hMyheap = GetProcessHeap();

    if (hMyheap == NULL)
    {
        DisplayError(TEXT("GetProcessHeap"));
    }

    // Allocate memory on the heap
    LPVOID buffer = HeapAlloc(hMyheap, HEAP_ZERO_MEMORY, fileSize);
    if (buffer == NULL)
    {
        DisplayError(TEXT("HeapAlloc"));
        CloseHandle(hFile);
        return NULL;
    }

    // Read the file content
    DWORD bytesRead;
    if (!ReadFile(hFile, buffer, (DWORD)fileSize, &bytesRead, NULL))
    {
        DisplayError(TEXT("ReadFile"));
        HeapFree(GetProcessHeap(), 0, buffer);
        CloseHandle(hFile);
        return NULL;
    }

    CloseHandle(hFile);
    return buffer;
}

BOOL RC4_decryption_systemfunction032(LPVOID buffer, TCHAR* encryption_key, int64_t fileSize)
{

    HMODULE hAdvapi32 = LoadLibraryW(L"advapi32");
    if (!hAdvapi32)
    {
        wprintf(L"[1] Error: RC4_decryption_systemfunction032 function has been failed.");
        DisplayError(TEXT("advapi32"));
        return FALSE;
    }

    _SystemFuntion032 SystemFunction032 = (_SystemFuntion032)GetProcAddress(hAdvapi32, "SystemFunction032");
    if (!SystemFunction032)
    {
        DisplayError(TEXT("GetProcAddress"));
        FreeLibrary(hAdvapi32);
        return FALSE;
    }


    //convert the wide character string (Unicode) to an ASCII (ANSI) string for RC4 decryption process
    char ansiKey[256];  // Ensure this buffer is large enough for your key
    WideCharToMultiByte(CP_ACP, 0, encryption_key, -1, ansiKey, sizeof(ansiKey), NULL, NULL);

    struct ustring key;
    struct ustring _data;

    DWORD keyLength = (DWORD)_tcslen(encryption_key) * sizeof(TCHAR);
    key.Buffer = (PUCHAR)ansiKey;
    key.Lenght = key.MaximumLength = strlen(ansiKey);

    _data.Buffer = (PUCHAR)buffer;
    _data.Lenght = _data.MaximumLength = (DWORD)fileSize;

    NTSTATUS status = SystemFunction032(&_data, &key);
    FreeLibrary(hAdvapi32);
    if (status != STATUS_SUCCESS)
    {
        DisplayError(TEXT("SystemFunction032"));
        return FALSE;
    }
    return TRUE;
}

// Write File content to the file for both encryption and decryption
BOOL WriteFileContent(
    _In_ LPVOID buffer,
    _In_ SIZE_T bufferSize,
    _In_ TCHAR* outputpath)
{

    BOOL bErrorFlag = FALSE;

    if (buffer == NULL)
    {
        wprintf(L"[!] Error: Heap is empty nothing to write to file.");
        return FALSE;
    }

    HANDLE hFile = NULL;
    hFile = CreateFile(
        outputpath,            // name of the write
        GENERIC_WRITE,         // open for writing
        0,                     // do not share
        NULL,                  // default security
        CREATE_ALWAYS,         // create new file only
        FILE_ATTRIBUTE_NORMAL, // normal file
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DisplayError(TEXT("CreateFile"));
        _tprintf(TEXT("Terminal failure: Unable to open file \"%s\" for write.\n"), outputpath);
        return FALSE;
    }

    _tprintf(TEXT("[*] Start Writing %d bytes to %s.\n"), bufferSize, outputpath);
    DWORD dwBytesWritten = 0;
    bErrorFlag = WriteFile(
        hFile,           // open file handle
        buffer,          // start of data to write
        bufferSize,      // number of bytes to write
        &dwBytesWritten, // number of bytes that were written
        NULL             // no overlapped structure
    );

    if (FALSE == bErrorFlag)
    {
        DisplayError(TEXT("WriteFile"));
        wprintf(L"[!] Error: Unable to write to file.\n");
    }
    CloseHandle(hFile);
    return TRUE;
}

struct commandline_struct
{
    BOOL decryption_status;
    _TCHAR* encryption_key;   // Encryption key
    _TCHAR* input_file_name;  // Input file name
    _TCHAR* output_file_path; // Output file name

} cmdline;


VOID XOR(const char* data, SIZE_T data_len, char* result) {
    for (int i = 0; i < data_len; i++) {
        result[i] = data[i] ^ 0x3d;
    }
}

/*
Function: BOOL validate_key(LPWSTR user_key)

- Description: This function validates an encryption key provided by the user. It is specifically tailored for use in an RC4 decryption process. The validation process involves converting the key from a wide character Unicode string to an ASCII string and then performing an XOR operation to check against a predefined buffer 'xor_buffer'. This approach is typically used to verify that the input key matches a specific format or value expected by the decryption algorithm.

- Parameters:
  - LPWSTR user_key: A pointer to a wide character string representing the user-provided encryption key. The use of 'LPWSTR' ensures compatibility with Unicode characters in the key.

- Returns:
  - BOOL: Returns TRUE if the key is validated successfully, FALSE otherwise.

- Functionality:
  1. Converts the wide character string (Unicode) to an ASCII (ANSI) string using 'WideCharToMultiByte'. This conversion is necessary for the RC4 decryption process which operates on ASCII characters.
  2. Calculates the length of the user-provided key using '_tcsclen' to determine the amount of memory needed for processing.
  3. Allocates memory dynamically for a buffer 'xor_result_buffer' using 'calloc' to store the results of the XOR operation.
  4. Checks for successful memory allocation. If allocation fails, prints an error message and returns 1 (indicating error).
  5. Calls the 'XOR' function to perform an XOR operation on the ANSI version of the key.
  6. Compares the result of the XOR operation with a predefined buffer 'xor_buffer' using 'memcmp'. If they match, it indicates that the user key is valid.
  7. Frees the dynamically allocated memory for 'xor_result_buffer'.
*/

BOOL validate_key(LPWSTR user_key) {
    //convert the wide character string (Unicode) to an ASCII (ANSI) string for RC4 decryption process
    char ansiKey[MAX_PATH];  // Ensure this buffer is large enough for your key
    WideCharToMultiByte(CP_ACP, 0, user_key, -1, ansiKey, sizeof(ansiKey), NULL, NULL);

   
    SIZE_T user_input_len = _tcsclen(user_key);
    char* xor_result_buffer = (char*)calloc(user_input_len, sizeof(char));
    if (!xor_result_buffer) {
        _tprintf(_T("Memory allocation failed\n"));
        return 1; // or handle the error as appropriate
    }
    XOR(ansiKey, user_input_len, xor_result_buffer);

    if (user_input_len == sizeof(xor_buffer) && memcmp(xor_buffer, xor_result_buffer, sizeof(xor_buffer)) == 0) {
        return TRUE;
    }
    else {
        return FALSE;
    }
    free(xor_result_buffer);
}

// Function to display help message
static void ShowHelp()
{
    wprintf(L"Usage:\n");
    wprintf(L"[!] Usage information is currently unavailable. Please try to find it yourself.\n");
    //wprintf(L"  decrypt.exe -decrypt -key <EncryptionKey> -in <InputFilename> -out <OutputFilename>\n");
    //wprintf(L"Options:\n");
    //wprintf(L"   -d/--decrypt            Decrypt the input file.\n");
    //wprintf(L"   -k/--key <key>          Specify the encryption key.\n");
    //wprintf(L"   -i/--in <filename>      Specify the input filename.\n");
    //wprintf(L"   -o/--out <filename>     Specify the output filename.\n");
}

VOID print_currentdir_path() {
    TCHAR currentDir[MAX_PATH];
    GetCurrentDirectory(MAX_PATH, currentDir);
    wprintf(L"Current Directory: %s\n", currentDir);
}

/*
Function: BOOL validatePNGFile(LPWSTR encrypted_file_path)

- Description: This function checks if the specified file is a PNG file by validating its header. It reads the first few bytes of the file and compares them against a predefined PNG file header that has been XORed with a specific key. This function is essential in scenarios where the decryption process should only proceed if the input file is of a particular format, in this case, a PNG file.

- Parameters:
  - LPWSTR encrypted_file_path: A pointer to a wide character string specifying the path to the encrypted file. The 'LPWSTR' type is used for compatibility with Unicode file paths.

- Returns:
  - BOOL: Returns TRUE if the file is a valid PNG file, FALSE otherwise.

- Functionality:
  1. Initializes a buffer to store the first bytes of the file and attempts to open the file using 'CreateFileW'. It uses the GENERIC_READ mode to read the file's content.
  2. Checks if the file path is NULL or if the file cannot be opened, and in such cases, prints an error message and returns FALSE.
  3. Reads the first few bytes of the file into the buffer using 'ReadFile'. The number of bytes read is based on the expected length of the PNG header.
  4. Performs an XOR operation on a predefined buffer 'xor_png_header' with the key 0x3d to decrypt it.
  5. Compares the decrypted header with the bytes read from the file using 'memcmp'. If they match, it confirms that the file is a PNG file.
  6. Closes the file handle using 'CloseHandle' to free resources.
*/
BOOL validatePNGFile(LPWSTR encrypted_file_path) {
    char Buffer[16] = { 0 };
    HANDLE hFile = NULL;
    if (encrypted_file_path == NULL) {
        wprintf(L"[ERROR] Error Reading file....");
        return FALSE;
    }
    hFile = CreateFileW(
        encrypted_file_path,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        DisplayError(TEXT("CreateFile"));
        _tprintf(TEXT("Terminal failure: Unable to open file.\n"));
        return FALSE;
    }
    DWORD dwBytesRead = 0;
    if (ReadFile(
        hFile,
        Buffer,
        sizeof(Buffer),
        &dwBytesRead, NULL
    ) == FALSE) {
        DisplayError(TEXT("ReadFile"));
        _tprintf(TEXT("Terminal failure: Unable to read file.\n"));
        CloseHandle(hFile);
        return FALSE;
    }
    size_t xor_png_header_length = sizeof(xor_png_header) / sizeof(xor_png_header[0]);
    //Decrypt the buffer. validate the file based on the file header. 
    for (size_t i = 0; i < xor_png_header_length; i++) {
        xor_png_header[i] ^= 0x3d;
    }

    if (sizeof(Buffer) == xor_png_header_length && memcmp(Buffer, xor_png_header, xor_png_header_length) == 0) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

int __cdecl _tmain(int argc, TCHAR* argv[])
{
   
    RtlZeroMemory(&cmdline, sizeof(cmdline));

    cmdline.decryption_status = FALSE;
    cmdline.encryption_key = NULL;
    cmdline.input_file_name = NULL;
    cmdline.output_file_path = NULL;

    if (argc < 2) {
        wprintf(L"[!] No argument provided. Please pass proper argument. \n");
        return 0;
    }
    
    for (int i = 1; i < argc; i++)
    {
        if (argv[i][0] != L'-') // Check for wide character '-'
            break;

        else if (wcscmp(argv[i], L"-d") == 0 || wcscmp(argv[i], L"--decrypt") == 0)
        {
            cmdline.decryption_status = TRUE;
        }
        else if (wcscmp(argv[i], L"-k") == 0 || wcscmp(argv[i], L"--key") == 0)
        {
            if (i + 1 == argc)
            {
                wprintf(L"[!] Error: missing command specification after -k/--key \n");
                ShowHelp();
                return EXIT_FAILURE;
            }
            cmdline.encryption_key = argv[++i];
        }
        else if (wcscmp(argv[i], L"-i") == 0 || wcscmp(argv[i], L"--in") == 0)
        {
            if (i + 1 == argc)
            {
                wprintf(L"[!] Error: Input file is missing \n");
                ShowHelp();
                return EXIT_FAILURE;
            }
            cmdline.input_file_name = argv[++i];
        }
        else if (wcscmp(argv[i], L"-o") == 0 || wcscmp(argv[i], L"--out") == 0)
        {
            if (i + 1 == argc)
            {
                wprintf(L"[!] Error: output file path is missing \n");
                ShowHelp();
                return EXIT_FAILURE;
            }
            cmdline.output_file_path = argv[++i];
        }
        else
        {
            wprintf(L"unknown option \"%s\"\n", argv[i]);
        }
    }

    if (!validate_key(cmdline.encryption_key)) {
        wprintf(L"[ERROR] Wrong Encryption key\n");
        return EXIT_FAILURE;
    }
    
    if (cmdline.output_file_path == NULL) {
        return 0;
    }




    // The User should only select a file with proper header in order to prgoram to get execute. 
    // File with Header --> 96 10 3C B1 57 B2 C0 22 F0 2A 5E E6 44 53 59 3B
    // This value protected via XOR with key 0x3d in buffer called xor_png_header
    if (!validatePNGFile(cmdline.input_file_name)) {
        return 0;
    }

    if (cmdline.decryption_status)
    {

        LPVOID fileContent = NULL;
        LARGE_INTEGER  fsize;

        wprintf(L"[*] Filename: %s\n", cmdline.input_file_name);

        wprintf(L"[*] Encryption key: %s\n", cmdline.encryption_key);
        wprintf(L"[*] output filename: %s\n", cmdline.output_file_path);
        fsize = getFileSize(cmdline.input_file_name);
        if (fsize.QuadPart == -1)
        {
            // Handle error, for example:
            wprintf(L"[!] Error: Unable to get file size or file does not exist.\n");
            return EXIT_FAILURE;
        }
        fileContent = ReadFileContent(cmdline.input_file_name, fsize.QuadPart);
        if (fileContent != NULL)
        {
            if (RC4_decryption_systemfunction032(fileContent, cmdline.encryption_key, fsize.QuadPart))
            {
                if (cmdline.output_file_path != NULL && WriteFileContent(fileContent, fsize.QuadPart, cmdline.output_file_path) == FALSE)
                {
                    wprintf(L"[!] Error: WriteFileContent.\n");
                }
                wprintf(L"[*] File has been saved successfully at %s\n", cmdline.output_file_path);
            }
        }

        // Heap free;
        HeapFree(GetProcessHeap(), 0, fileContent);
    }

    wprintf(L"[OK] Process has been done. Exit.\n");
    return 0;
   
}
